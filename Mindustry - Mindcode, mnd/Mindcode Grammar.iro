
## This file can be used in:
## https://eeyo.io/iro/
## to design and debug the grammar
## and then to create the TextMate grammar file for VS Code


#################################################################
## Iro
################################################################ 
##
## * Press Ctrl + '+'/'-' To Zoom in
## * Press Ctrl + S to save and recalculate... 
## * Documents are saved to web storage.
## * Only one save slot supported.
## * Matches cannot span lines.
## * Unicode chars must be defined in \u0000 to \uffff format.
## * All matches must be contained by a single group ( ... )
## * Look behinds not permitted, (?<= or (?<!
## * Look forwards are permitted (?= or (?!
## * Constants are defined as __my_const = (......)
## * The \= format allows unescaped regular expressions
## * Constants referenced by match \= $${__my_const}
## * Constants can reference other constants
## * You are free to delete all the default scopes.
## * Twitter : ainslec , Web: http://eeyo.io/iro
##
################################################################

name                   = mindcode
file_extensions []     = mnd, mindcode;
textmate_compatible     = true

################################################################
## Constants
################################################################

// Konstanten
__CONST \= (\b[_]?[A-Z][A-Z0-9_]*\b)

// Variablen
__Variable \= (\b[_]?[A-Za-z][A-Za-z0-9_]*\b)


################################################################
## Styles
################################################################


styles [] {

.comment : style {
   color                 = light_green
   italic                = true
   ace_scope             = comment
   textmate_scope        = comment
   pygments_scope        = Comment
}

.keyword : style {
   color                 = cyan
   ace_scope             = keyword
   textmate_scope        = keyword.control
   pygments_scope        = Keyword
}


// true, false, null
.constLng : style {
   color                 = yellow
   ace_scope             = keyword
   textmate_scope        = constant.language
   pygments_scope        = Keyword
}


.heapStack : style {
   color                 = yellow
   italic                = true
   ace_scope             = keyword
   textmate_scope        = storage.type
   pygments_scope        = Keyword
}



// Operatoren
.operator : style {
   color                 = violet
   ace_scope             = keyword
   textmate_scope        = keyword.operator
   pygments_scope        = Keyword
}


// Funktions-Name
.fnctName : style {
   color                 = yellow
   bold                  = true
   ace_scope             = keyword
   textmate_scope        = entity.name.function
   pygments_scope        = Keyword
}



// Objekt-Property
.objProperty : style {
   color                 = cyan
   bold                  = true
   ace_scope             = keyword
   textmate_scope        = entity.name.function
   pygments_scope        = Keyword
}

// Variablen
.variable : style {
   color                 = pink
   bold                  = true
   ace_scope             = keyword
   textmate_scope        = entity.name.function
   pygments_scope        = Keyword
}

.ressourceRef : style {
   color                 = purple
   ace_scope             = keyword
   textmate_scope        = keyword
   pygments_scope        = Keyword
}


.const : style {
   color                 = orange
   ace_scope             = keyword
   textmate_scope        = keyword
   pygments_scope        = Keyword
}

.numeric : style {
   color                 = gold
   ace_scope             = constant.numeric
   textmate_scope        = constant.numeric
   pygments_scope        = Number
}

.punctuation : style {
   color                 = red_2
   ace_scope             = punctuation
   textmate_scope        = punctuation
   pygments_scope        = Punctuation
}

.assign1 : style {
   color                 = light_blue
   ace_scope             = punctuation
   textmate_scope        = punctuation
   pygments_scope        = Punctuation
}

.assign2 : style {
   color                 = light_blue
   bold                  = true
   ace_scope             = punctuation
   textmate_scope        = punctuation
   pygments_scope        = Punctuation
}

.assign3 : style {
   color                 = light_blue
   italic                = true
   bold                  = true
   ace_scope             = punctuation
   textmate_scope        = punctuation
   pygments_scope        = Punctuation
}


.text : style {
   color                 = brown
   ace_scope             = text
   textmate_scope        = text
   pygments_scope        = String
}

.illegal : style {
   color                 = white
   background_color      = red
   ace_scope             = invalid
   textmate_scope        = invalid
   pygments_scope        = Generic.Error
}

}

#################################################
## Parse contexts
#################################################

contexts [] {

##############################################
## Main Context - Entry point context
##############################################

main : context {

   // referenziert Mindustry Game-Objekte
   : pattern {
      regex          \= (@[a-z-]+)
      styles []       = .ressourceRef;
   }

//   // def: Funktions-Name
//   : pattern {
//      regex          \= (\b(def)\s+([a-zA-Z_$]\w*)?\s*(\()(?:.*?)(\)))
//      styles []       = .fnctName;
//   }

   : include "function_definition";


// xxxxxx

   : include "defaultSyntax";


   // allocate stack, heap
   : pattern {
      regex          \= (allocate|stack in|heap in)
      styles []       = .heapStack;
   }


   : pattern {
      regex          \= $${__CONST}
      styles []       = .const;
   }

   : pattern {
      regex          \= $${__Variable}
      styles []       = .variable;
   }

   : pattern {
      regex          \= (=)
      styles []       = .assign1;
   }

   : pattern {
      regex          \= (==)
      styles []       = .assign2;
   }

   : pattern {
      regex          \= (===)
      styles []       = .assign3;
   }


   
   : include "numeric" ;
   
   : inline_push {
      regex          \= (\{)
      styles []       = .punctuation;
      : pop {  
         regex       \= (\})
         styles []    = .punctuation;
      }
      : include "main" ;
   }
   
   : pattern {
      regex          \= (;)
      styles []       = .punctuation;
   }
   
   : inline_push {
      regex          \= (\")
      styles []       = .punctuation;
      default_style   = .text
      : pop {
         regex       \= (\")
         styles []    = .punctuation;
      }
   }
   
   : inline_push {
      regex          \= (\()
      styles []       = .punctuation;
      : pop {
         regex       \= (\))
         styles []    = .punctuation;
      }
      : include "numeric" ;
      : pattern {
         regex       \= (,)
         styles []    = .punctuation;
      }
   }
   
   : include "multi_line_comment" ;
   
   : pattern {
      regex          \= (//.*)
      styles []       = .comment;
   }
   
   : pattern {
      regex          \= ([^\s])
      styles []       = .illegal;
   }
   
}

#################################################
## End of Contexts
#################################################


/*

   push
      which does the job of pattern 
      but also pushes new context onto the stack. 
      Different regexes will be defined to apply in each context.
      
   pop 
      which also works like pattern 
         but the pops the current context from the stack

   inline_push
      allows you to specify something like “anonymous context”, 
      living only in that one rule.

*/


## Numeric Context

numeric : context {
   : pattern {
      regex          \= (\b\d+)
      styles []       = .numeric;
   }
}

## Multi Line Comment Context

multi_line_comment : context {
   description        = multiline
   : inline_push {
      regex          \= (/\*)
      styles []       = .comment;
      default_style   = .comment
      : pop {
         regex       \= (\*/)
         styles []    = .comment;
      }
   }
}


defaultSyntax : context {
   : pattern {
      regex          \= (if|then|end|while|for)
      styles []       = .keyword;
   }

   : pattern {
      regex          \= (true|false|null)
      styles []       = .constLng;
   }

   // Operatoren
   : pattern {
      // ===|==
      // Ternary \?\:|
      regex          \= (!|\*|\-|\+|\+|=|!=|<=|>=|<>|<|>|!|&&|\|\||\*=|\+=|\-=)
      styles []       = .operator;
   }


   : pattern {
      regex          \= ($${__Variable}\.$${__Variable})
      styles []       = .objProperty;
   }

}



function_definition : context {
   // style zum debuggen: illegal
   // def functionName(params) … end
   : inline_push  {
      // match 'def' in: def functionName(params) … end
      regex          \= (\b(def)\s+)
      styles []       = .keyword;

      : pop {
         // match 'end' in: def functionName(params) … end
         regex       \= (end)
         styles []    = .keyword;
      }

      : pattern {
         // match 'functionName' in: def functionName(params) … end
         regex    \= (([a-zA-Z_$]\w*)\s*(\())
         styles [] = .fnctName;
      }      

/*
      : pattern {
         // match 'params' in: def functionName(params) … end
         // regex    \= (([a-zA-Z_$]\w*)(,\s*([a-zA-Z_$]\w*)))
         // regex    \= ([a-zA-Z_$]\w*)
         regex    \= ([^\)]+)
         styles [] = .illegal;
      }      
*/

      : pattern {
         // match 'params' in: def functionName(params) … end
         // regex    \= (([a-zA-Z_$]\w*)(,\s*([a-zA-Z_$]\w*)))
         // regex    \= ([a-zA-Z_$]\w*)
         regex    \= ([\)])
         styles [] = .fnctName;
      }      


      
/*      
   : pattern {
      regex          \= (if|then|end|while|for)
      styles []       = .keyword;
   }

      : pattern {
         // alles nach dem Functionname bis vors Ende
         regex          \= ([^\)]+)
         styles [] = .variable;
      }      
      : pattern {
         // )
         //  \= (\b(def)\s+([a-zA-Z_$]\w*)?\s*(\()(?:.*?)(\)))
         regex          \= ((\)))
         styles [] = .illegal;
      }      
*/

   }
}

   
}


